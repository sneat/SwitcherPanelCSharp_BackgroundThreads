/* -LICENSE-START-
** Copyright (c) 2011 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using System.Runtime.InteropServices;

using BMDSwitcherAPI;
using System.Threading;

namespace SwitcherPanelCSharp
{
    public partial class SwitcherPanel : Form
    {
        private IBMDSwitcherDiscovery m_switcherDiscovery;
        private IBMDSwitcher m_switcher;
        private IBMDSwitcherMixEffectBlock m_mixEffectBlock1;

        private SwitcherMonitor m_switcherMonitor;
        private MixEffectBlockMonitor m_mixEffectBlockMonitor;

        private bool m_moveSliderDownwards = false;
        private bool m_currentTransitionReachedHalfway = false;

        private List<InputMonitor> m_inputMonitors = new List<InputMonitor>();

        /// <summary>
        /// The Main Thread ID
        /// </summary>
        private static int mainThreadId;

        /// <summary>
        /// Allow simple checking of whether we are on the Main Thread or a Background Thread
        /// </summary>
        public static bool IsMainThread
        {
            get
            {
                return Thread.CurrentThread.ManagedThreadId == mainThreadId;
            }
        }

        public SwitcherPanel()
        {
            InitializeComponent();

            // Populate the mainThreadId with the current thread id (since it's the main one)
            mainThreadId = Thread.CurrentThread.ManagedThreadId;

            // All interactions with the ATEM switcher need to happen on the background thread. Trying to interact
            // with the DLL from any thread other than the thread it was created on will cause an exception.
            // All interactions with the GUI need to happen on the main thread.
            // This means we keep doing a lot of switching between main and background threads via new Thread() and this.Invoke()
            new Thread(() =>
            {
                m_switcherMonitor = new SwitcherMonitor();
                // note: this invoke pattern ensures our callback is called in the main thread. We are making double
                // use of lambda expressions here to achieve this.
                // Essentially, the events will arrive at the callback class (implemented by our monitor classes)
                // on a separate thread. We must marshal these to the main thread, and we're doing this by calling
                // invoke on the Windows Forms object. The lambda expression is just a simplification.
                m_switcherMonitor.SwitcherDisconnected += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => SwitcherDisconnected())));

                m_mixEffectBlockMonitor = new MixEffectBlockMonitor();
                m_mixEffectBlockMonitor.ProgramInputChanged += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => UpdateProgramButtonSelection())));
                m_mixEffectBlockMonitor.PreviewInputChanged += new SwitcherEventHandler((s, a) => UpdatePreviewButtonSelection());
                m_mixEffectBlockMonitor.TransitionFramesRemainingChanged += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => UpdateTransitionFramesRemaining())));
                m_mixEffectBlockMonitor.TransitionPositionChanged += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => UpdateSliderPosition())));
                m_mixEffectBlockMonitor.InTransitionChanged += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => OnInTransitionChanged())));


                m_switcherDiscovery = new CBMDSwitcherDiscovery();
                if (m_switcherDiscovery == null)
                {
                    this.Invoke((Action)(() => { MessageBox.Show("Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.", "Error"); }));
                    Environment.Exit(1);
                }
            }).Start();
            SwitcherDisconnected();		// start with switcher disconnected
        }

        private void OnInputLongNameChanged(object sender, object args)
        {
            this.Invoke((Action)(() => UpdatePopupItems()));
        }

        private void SwitcherConnected()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(SwitcherConnected).Start();
                return;
            }
            this.Invoke((Action)(() => { buttonConnect.Enabled = false; }));

            // Get the switcher name:
            string switcherName;
            m_switcher.GetProductName(out switcherName);
            this.Invoke((Action)(() => { textBoxSwitcherName.Text = switcherName; }));

            // Install SwitcherMonitor callbacks:
            m_switcher.AddCallback(m_switcherMonitor);

            // We create input monitors for each input. To do this we iterate over all inputs:
            // This will allow us to update the combo boxes when input names change:
            IBMDSwitcherInputIterator inputIterator = null;
            IntPtr inputIteratorPtr;
            Guid inputIteratorIID = typeof(IBMDSwitcherInputIterator).GUID;
            m_switcher.CreateIterator(ref inputIteratorIID, out inputIteratorPtr);
            if (inputIteratorPtr != null)
            {
                inputIterator = (IBMDSwitcherInputIterator)Marshal.GetObjectForIUnknown(inputIteratorPtr);
            }

            if (inputIterator != null)
            {
                IBMDSwitcherInput input;
                inputIterator.Next(out input);
                while (input != null)
                {
                    InputMonitor newInputMonitor = new InputMonitor(input);
                    input.AddCallback(newInputMonitor);
                    newInputMonitor.LongNameChanged += new SwitcherEventHandler(OnInputLongNameChanged);

                    m_inputMonitors.Add(newInputMonitor);

                    inputIterator.Next(out input);
                }
            }

            // We want to get the first Mix Effect block (ME 1). We create a ME iterator,
            // and then get the first one:
            m_mixEffectBlock1 = null;

            IBMDSwitcherMixEffectBlockIterator meIterator = null;
            IntPtr meIteratorPtr;
            Guid meIteratorIID = typeof(IBMDSwitcherMixEffectBlockIterator).GUID;
            m_switcher.CreateIterator(ref meIteratorIID, out meIteratorPtr);
            if (meIteratorPtr != null)
            {
                meIterator = (IBMDSwitcherMixEffectBlockIterator)Marshal.GetObjectForIUnknown(meIteratorPtr);
            }

            if (meIterator == null)
                return;

            if (meIterator != null)
            {
                meIterator.Next(out m_mixEffectBlock1);
            }

            if (m_mixEffectBlock1 == null)
            {
                this.Invoke((Action)(() => { MessageBox.Show("Unexpected: Could not get first mix effect block", "Error"); }));
                return;
            }

            // Install MixEffectBlockMonitor callbacks:
            m_mixEffectBlock1.AddCallback(m_mixEffectBlockMonitor);

            this.Invoke((Action)(() =>
            {
                MixEffectBlockSetEnable(true);
            }));
            UpdatePopupItems();
            UpdateTransitionFramesRemaining();
            UpdateSliderPosition();
        }

        private void SwitcherDisconnected()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(SwitcherDisconnected).Start();
                return;
            }
            // Remove all input monitors, remove callbacks
            foreach (InputMonitor inputMon in m_inputMonitors)
            {
                inputMon.Input.RemoveCallback(inputMon);
                inputMon.LongNameChanged -= new SwitcherEventHandler(OnInputLongNameChanged);
            }
            m_inputMonitors.Clear();

            if (m_mixEffectBlock1 != null)
            {
                // Remove callback
                m_mixEffectBlock1.RemoveCallback(m_mixEffectBlockMonitor);

                // Release reference
                m_mixEffectBlock1 = null;
            }

            if (m_switcher != null)
            {
                // Remove callback:
                m_switcher.RemoveCallback(m_switcherMonitor);

                // release reference:
                m_switcher = null;
            }
            this.Invoke((Action)(() =>
            {
                MixEffectBlockSetEnable(false);
                buttonConnect.Enabled = true;
                textBoxSwitcherName.Text = "";
            }));
        }

        private void MixEffectBlockSetEnable(bool enable)
        {
            if (!SwitcherPanel.IsMainThread)
            {
                this.Invoke((Action)(() => { MixEffectBlockSetEnable(enable); }));
                return;
            }
            comboBoxProgramSel.Enabled = enable;
            comboBoxPreviewSel.Enabled = enable;
            buttonAuto.Enabled = enable;
            buttonCut.Enabled = enable;
            trackBarTransitionPos.Enabled = enable;
        }

        private void UpdatePopupItems()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(UpdatePopupItems).Start();
                return;
            }
            this.Invoke((Action)(() =>
            {
                // Clear the combo boxes:
                comboBoxProgramSel.Items.Clear();
                comboBoxPreviewSel.Items.Clear();
            }));

            // Get an input iterator.
            IBMDSwitcherInputIterator inputIterator = null;
            IntPtr inputIteratorPtr;
            Guid inputIteratorIID = typeof(IBMDSwitcherInputIterator).GUID;
            m_switcher.CreateIterator(ref inputIteratorIID, out inputIteratorPtr);
            if (inputIteratorPtr != null)
            {
                inputIterator = (IBMDSwitcherInputIterator)Marshal.GetObjectForIUnknown(inputIteratorPtr);
            }

            if (inputIterator == null)
                return;

            IBMDSwitcherInput input;
            inputIterator.Next(out input);
            while (input != null)
            {
                string inputName;
                long inputId;

                input.GetInputId(out inputId);
                input.GetLongName(out inputName);

                this.Invoke((Action)(() =>
                {
                    // Add items to list:
                    comboBoxProgramSel.Items.Add(new StringObjectPair<long>(inputName, inputId));
                    comboBoxPreviewSel.Items.Add(new StringObjectPair<long>(inputName, inputId));
                }));

                inputIterator.Next(out input);
            }

            UpdateProgramButtonSelection();
            UpdatePreviewButtonSelection();
        }

        private void UpdateProgramButtonSelection()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(UpdateProgramButtonSelection).Start();
                return;
            }
            long programId;

            m_mixEffectBlock1.GetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdProgramInput, out programId);

            // Select the program popup entry that matches the input id:
            foreach (StringObjectPair<long> item in comboBoxProgramSel.Items)
            {
                if (item.value == programId)
                {
                    this.Invoke((Action)(() => { comboBoxProgramSel.SelectedIndex = comboBoxProgramSel.Items.IndexOf(item); }));
                    break;
                }
            }
        }

        private void UpdatePreviewButtonSelection()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(UpdatePreviewButtonSelection).Start();
                return;
            }
            long previewId;

            m_mixEffectBlock1.GetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdPreviewInput, out previewId);

            // Select the program popup entry that matches the input id:
            foreach (StringObjectPair<long> item in comboBoxPreviewSel.Items)
            {
                if (item.value == previewId)
                {
                    this.Invoke((Action)(() => { comboBoxPreviewSel.SelectedIndex = comboBoxPreviewSel.Items.IndexOf(item); }));
                    break;
                }
            }
        }

        private void UpdateTransitionFramesRemaining()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(UpdateTransitionFramesRemaining).Start();
                return;
            }
            long framesRemaining;
            m_mixEffectBlock1.GetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdTransitionFramesRemaining, out framesRemaining);

            this.Invoke((Action)(() => { textBoxTransFramesRemaining.Text = String.Format("{0}", framesRemaining); }));
        }

        private void UpdateSliderPosition()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(UpdateSliderPosition).Start();
                return;
            }
            double transitionPos;

            m_mixEffectBlock1.GetFloat(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdTransitionPosition, out transitionPos);

            m_currentTransitionReachedHalfway = (transitionPos >= 0.50);

            this.Invoke((Action)(() =>
            {
                if (m_moveSliderDownwards)
                    trackBarTransitionPos.Value = 100 - (int)(transitionPos * 100);
                else
                    trackBarTransitionPos.Value = (int)(transitionPos * 100);
            }));
        }

        private void OnInTransitionChanged()
        {
            if (SwitcherPanel.IsMainThread)
            {
                new Thread(OnInTransitionChanged).Start();
                return;
            }
            int inTransition;

            m_mixEffectBlock1.GetFlag(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdInTransition, out inTransition);

            this.Invoke((Action)(() =>
            {
                if (inTransition == 0)
                {
                    // Toggle the starting orientation of slider handle if a transition has passed through halfway
                    if (m_currentTransitionReachedHalfway)
                    {
                        m_moveSliderDownwards = !m_moveSliderDownwards;
                        UpdateSliderPosition();
                    }
                    m_currentTransitionReachedHalfway = false;
                }
            }));
        }

        private void buttonConnect_Click(object sender, EventArgs e)
        {
            _BMDSwitcherConnectToFailure failReason = 0;
            string address = textBoxIP.Text;

            new Thread(() =>
            {
                try
                {
                    // Note that ConnectTo() can take several seconds to return, both for success or failure,
                    // depending upon hostname resolution and network response times, so it may be best to
                    // do this in a separate thread to prevent the main GUI thread blocking.
                    // Good news, now it's in a background thread
                    m_switcherDiscovery.ConnectTo(address, out m_switcher, out failReason);
                    SwitcherConnected();
                }
                catch (COMException)
                {
                    // An exception will be thrown if ConnectTo fails. For more information, see failReason.
                    this.Invoke((Action)(() =>
                    {
                        switch (failReason)
                        {
                            case _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureNoResponse:
                                MessageBox.Show("No response from Switcher", "Error");
                                break;
                            case _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureIncompatibleFirmware:
                                MessageBox.Show("Switcher has incompatible firmware", "Error");
                                break;
                            default:
                                MessageBox.Show("Connection failed for unknown reason", "Error");
                                break;
                        }
                    }));
                    return;
                }
            }).Start();

        }

        private void comboBoxProgramSel_SelectedIndexChanged(object sender, EventArgs e)
        {
            long inputId = ((StringObjectPair<long>)comboBoxProgramSel.SelectedItem).value;

            if (m_mixEffectBlock1 != null)
            {
                new Thread(() =>
                {
                    m_mixEffectBlock1.SetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdProgramInput,
                        inputId);
                }).Start();
            }
        }

        private void comboBoxPreviewSel_SelectedIndexChanged(object sender, EventArgs e)
        {
            long inputId = ((StringObjectPair<long>)comboBoxPreviewSel.SelectedItem).value;

            if (m_mixEffectBlock1 != null)
            {
                new Thread(() =>
                {
                    m_mixEffectBlock1.SetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdPreviewInput,
                    inputId);
                }).Start();
            }
        }

        private void buttonAuto_Click(object sender, EventArgs e)
        {
            if (m_mixEffectBlock1 != null)
            {
                new Thread(() =>
                {
                    m_mixEffectBlock1.PerformAutoTransition();
                }).Start();
            }
        }

        private void buttonCut_Click(object sender, EventArgs e)
        {
            if (m_mixEffectBlock1 != null)
            {
                new Thread(() =>
                {
                    m_mixEffectBlock1.PerformCut();
                }).Start();
            }
        }

        private void trackBarTransitionPos_Scroll(object sender, EventArgs e)
        {
            if (m_mixEffectBlock1 != null)
            {
                double position = trackBarTransitionPos.Value / 100.0;
                if (m_moveSliderDownwards)
                    position = (100 - trackBarTransitionPos.Value) / 100.0;

                new Thread(() =>
                {
                    m_mixEffectBlock1.SetFloat(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdTransitionPosition,
                    position);
                }).Start();
            }
        }

        /// <summary>
        /// Used for putting other object types into combo boxes.
        /// </summary>
        struct StringObjectPair<T>
        {
            public string name;
            public T value;

            public StringObjectPair(string name, T value)
            {
                this.name = name;
                this.value = value;
            }

            public override string ToString()
            {
                return name;
            }
        }
    }
}
